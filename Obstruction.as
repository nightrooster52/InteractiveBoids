package {	import flash.geom.Point;	public class Obstruction extends Boid {		public function Obstruction(master:BoidController) {			super(master);			cruisingSpeed = 10;			this.personalSpace = Math.random()*40 + 60;			this.sightRange = personalSpace;			this.graphics.clear();			this.graphics.beginFill(0x002244, 1);			graphics.drawCircle(0, 0, personalSpace);			this.graphics.beginFill(0x002244, .5);			graphics.drawCircle(0, 0, personalSpace + 8);			this.mass = 2;			this.currentVector.x = Math.random()*0.05 - .1;			this.currentVector.y = Math.random()*0.05 - .1;		}		public override function update():void {						currentSpeed = (cruisingSpeed - currentSpeed)/20;			currentVector = normalizeVector(currentVector,currentSpeed);						this.x += currentVector.x;			this.y += currentVector.y;						for (var i:uint = 0; i < master.boidArray.length; i++) {				var otherBoid:Boid = master.boidArray[i];				var currentDistance:Number = cartesianDistance(new Point(this.x,this.y),new Point(otherBoid.x,otherBoid.y));				if (currentDistance < personalSpace+otherBoid.personalSpace  && currentDistance != 0 ) {					var recoil_distance = (personalSpace+otherBoid.personalSpace) - currentDistance;					var nextVector:Point = normalizeVector(new Point(this.x - otherBoid.x, this.y - otherBoid.y), -recoil_distance/4);					otherBoid.currentVector.x += nextVector.x;					otherBoid.currentVector.y += nextVector.y;									}			}						if (this.x < 0 - personalSpace) {				this.x = master.WH.x + personalSpace;			}			if (this.y < 0- this.personalSpace) {				this.y = master.WH.y + personalSpace;			}			if (this.x > master.WH.x + personalSpace) {				this.x = 0 - personalSpace ;			}			if (this.y > master.WH.y + personalSpace) {				this.y = 0 - this.personalSpace ;			}					}	}}